"""
Vulnerability Scanner Module
"""

import requests
import json
from typing import Dict, List, Optional, Tuple
import time
from dataclasses import dataclass
from enum import Enum
from .vulnerability_database import VulnerabilityDatabase
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    NONE = "none"

@dataclass
class Vulnerability:
    id: str
    title: str
    description: str
    severity: Severity
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    affected_versions: Optional[str] = None
    fixed_versions: Optional[str] = None
    references: Optional[List[str]] = None
    recommendation: Optional[str] = None
    future_vuln: bool = False # Added for future vulnerabilities

@dataclass
class PackageRisk:
    package_name: str
    version: str
    risk_score: float  # 0-100
    risk_level: str  # "safe", "low", "medium", "high", "critical"
    vulnerability_count: int
    vulnerabilities: List[Vulnerability]
    recommendation: str

class VulnerabilityScanner:
    def __init__(self):
        """Initialize the vulnerability scanner with OSV API configuration."""
        self.osv_api_url = "https://api.osv.dev/v1/query"
        self.pypi_api_url = "https://pypi.org/pypi"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SBOM-Vulnerability-Scanner/1.0'
        })
        
        # Rate limiting configuration
        self.request_interval = 0.5  # Minimum time between requests (seconds)
        self.last_request_time = 0.0
        self.rate_limit_lock = threading.Lock()  # Thread-safe rate limiting
        
        # Risk calculation weights based on OSV severity levels
        self.severity_weights = {
            Severity.CRITICAL: 1.5,  # Critical vulnerabilities get highest weight
            Severity.HIGH: 1.3,      # High vulnerabilities get high weight
            Severity.MEDIUM: 1.0,    # Medium vulnerabilities get standard weight
            Severity.LOW: 0.7,       # Low vulnerabilities get reduced weight
            Severity.NONE: 0.0       # No severity gets no weight
        }
        
        # Risk thresholds for determining risk levels
        self.risk_thresholds = {
            "critical": 80.0,
            "high": 60.0,
            "medium": 30.0,
            "low": 5.0
        }
        
        # Initialize vulnerability database for caching
        self.vuln_db = VulnerabilityDatabase()

    def scan_package(self, package_name: str, version: str) -> PackageRisk:
        """Scan a single package for vulnerabilities."""
        try:
            print(f"üîç Scanning {package_name} {version}")

            # If version is flexible, unknown, latest, or *, mark as N/A
            if version in ["flexible", "unknown", "latest", "*"]:
                print(f"‚ö†Ô∏è {package_name} has a flexible/unknown version - marking as N/A")
                return self._create_na_package_risk(package_name, version)

            # Dynamic health check - check if package has health issues
            from .package_health_checker import PackageHealthChecker
            health_checker = PackageHealthChecker()
            health_issue = health_checker.check_package_health(package_name, version)
            if health_issue:
                severity = health_issue.get('severity', 'medium')
                details = health_issue.get('details', {})
                print(f"‚ö†Ô∏è {package_name} has {severity} health issues - adjusting risk level")
                # Map health severity to risk level and score
                if severity == 'critical':
                    risk_level = "critical"
                    risk_score = 95.0
                elif severity == 'high':
                    risk_level = "high"
                    risk_score = 80.0
                elif severity == 'medium':
                    risk_level = "medium"
                    risk_score = 60.0
                else:  # low
                    risk_level = "low"
                    risk_score = 30.0
                return PackageRisk(
                    package_name=package_name,
                    version=version,
                    risk_score=risk_score,
                    risk_level=risk_level,
                    vulnerability_count=1,  # At least 1 health issue
                    vulnerabilities=[],  # Will be populated by normal scanning
                    recommendation=details.get('warning', f"{severity.upper()}: {package_name} has {severity} health issues.")
                )
            
            # Special handling for known critical packages (keep pycrypto for now)
            if package_name.lower() == "pycrypto":
                print(f"‚ö†Ô∏è {package_name} is a known abandoned and vulnerable package - marking as CRITICAL")
                return PackageRisk(
                    package_name=package_name,
                    version=version,
                    risk_score=95.0,  # Very high risk score
                    risk_level="critical",
                    vulnerability_count=1,  # At least 1 vulnerability
                    vulnerabilities=[],  # Will be populated by normal scanning
                    recommendation="CRITICAL: PyCrypto is abandoned and has multiple security vulnerabilities. Use pycryptodome instead."
                )
            
            # Check cache first
            cached_summary = self.vuln_db.get_cached_package_summary(package_name, version)
            if cached_summary:
                print(f"üìã Using cached vulnerability data for {package_name}")
                # Convert cached vulnerability dicts back to Vulnerability objects
                cached_vulnerabilities = []
                for vuln_dict in cached_summary.vulnerabilities:
                    try:
                        severity_value = vuln_dict.get('severity', 'none')
                        if isinstance(severity_value, str):
                            severity = Severity(severity_value)
                        elif isinstance(severity_value, Severity):
                            severity = severity_value
                        else:
                            severity = Severity.NONE
                        
                        vuln = Vulnerability(
                            id=vuln_dict.get('cve_id', ''),
                            title=vuln_dict.get('cve_id', ''),
                            description=vuln_dict.get('description', ''),
                            severity=severity,
                            cve_id=vuln_dict.get('cve_id'),
                            cvss_score=vuln_dict.get('cvss_score'),
                            affected_versions=vuln_dict.get('affected_versions'),
                            references=vuln_dict.get('references', []),
                            recommendation=vuln_dict.get('recommendation', '')
                        )
                        cached_vulnerabilities.append(vuln)
                    except Exception as e:
                        print(f"Error converting cached vulnerability: {e}")
                        continue
                print(f"[DEBUG] Returning {len(cached_vulnerabilities)} cached vulnerabilities for {package_name}")
                return PackageRisk(
                    package_name=package_name,
                    version=version,
                    risk_score=cached_summary.risk_score,
                    risk_level=cached_summary.risk_level,
                    vulnerability_count=cached_summary.vulnerability_count,
                    vulnerabilities=cached_vulnerabilities,
                    recommendation=cached_summary.recommendation
                )
            # Get package information from PyPI
            pkg_info = self._get_package_info(package_name)
            if not pkg_info:
                print(f"‚ùå No PyPI info found for {package_name}")
                return self._create_na_package_risk(package_name, version)
            print(f"‚úÖ PyPI info found for {package_name}")
            # Search for vulnerabilities (with rate limiting)
            vulnerabilities, has_data_available = self._search_vulnerabilities(package_name, version)
            print(f"üîç Found {len(vulnerabilities)} vulnerabilities for {package_name}")
            for v in vulnerabilities:
                print(f"[DEBUG] Parsed vulnerability: {v}")
            
            # If no data is available for this package, mark as N/A
            if not has_data_available and len(vulnerabilities) == 0:
                print(f"‚ö†Ô∏è {package_name} has no vulnerability data available - marking as N/A")
                return self._create_na_package_risk(package_name, version)
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(vulnerabilities)
            vulnerability_count = len(vulnerabilities)
            risk_level = self._determine_risk_level(risk_score, vulnerability_count)
            # Generate recommendation
            recommendation = self._generate_recommendation(vulnerabilities, risk_level)
            # Cache the results
            from .vulnerability_database import PackageVulnerabilitySummary
            # Store vulnerabilities as dicts for JSON serialization
            vuln_dicts = [
                {
                    'cve_id': v.cve_id,
                    'severity': v.severity.value if hasattr(v.severity, 'value') else str(v.severity),
                    'cvss_score': v.cvss_score,
                    'description': v.description,
                    'affected_versions': v.affected_versions,
                    'references': v.references,
                    'recommendation': v.recommendation
                } for v in vulnerabilities
            ]
            print(f"[DEBUG] Caching {len(vuln_dicts)} vulnerabilities for {package_name}")
            summary = PackageVulnerabilitySummary(
                package_name=package_name,
                version=version,
                risk_score=risk_score,
                risk_level=risk_level,
                vulnerability_count=vulnerability_count,
                vulnerabilities=vuln_dicts,  # Store full list
                recommendation=recommendation,
                last_checked=time.strftime('%Y-%m-%d %H:%M:%S')
            )
            self.vuln_db.cache_package_summary(package_name, version, summary)
            print(f"üìä {package_name}: Risk Level = {risk_level}, Score = {risk_score}")
            return PackageRisk(
                package_name=package_name,
                version=version,
                risk_score=risk_score,
                risk_level=risk_level,
                vulnerability_count=len(vulnerabilities),
                vulnerabilities=vulnerabilities,
                recommendation=recommendation
            )
        except Exception as e:
            print(f"‚ùå Error scanning {package_name}: {e}")
            return self._create_safe_package_risk(package_name, version)

    def _get_package_info(self, package_name: str) -> Optional[Dict]:
        """Get package information from PyPI."""
        try:
            response = self.session.get(f"{self.pypi_api_url}/{package_name}/json", timeout=10)
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            print(f"Error fetching package info for {package_name}: {e}")
        return None

    def _rate_limit_request(self):
        """Apply rate limiting to avoid overwhelming the OSV API (thread-safe)."""
        with self.rate_limit_lock:
            current_time = time.time()
            time_since_last = current_time - self.last_request_time
            
            if time_since_last < self.request_interval:
                sleep_time = self.request_interval - time_since_last
                time.sleep(sleep_time)
            
            self.last_request_time = time.time()

    def _search_vulnerabilities(self, package_name: str, version: str) -> tuple[List[Vulnerability], bool]:
        """Search for vulnerabilities using OSV API. Returns (vulnerabilities, has_data_available)."""
        vulnerabilities = []
        alias_to_canonical = {}  # Map each alias to a canonical vulnerability index
        seen_aliases = set()     # Track all seen aliases (normalized)
        seen_desc_versions = set()  # Track (description, affected_versions) pairs
        try:
            print(f"   üîç Searching OSV for package: '{package_name}' version: '{version}'")
            self._rate_limit_request()
            query = {
                "package": {
                    "name": package_name,
                    "ecosystem": "PyPI"
                },
                "version": version
            }
            response = self.session.post(self.osv_api_url, json=query, timeout=15)
            if response.status_code == 200:
                data = response.json()
                vulns = data.get('vulns', [])
                print(f"   üìä Found {len(vulns)} vulnerabilities for '{package_name}'")
                def sort_key(vuln):
                    if 'database_specific' in vuln and 'severity' in vuln['database_specific']:
                        return 0
                    elif vuln.get('severity'):
                        return 1
                    else:
                        return 2
                vulns.sort(key=sort_key)
                for vuln in vulns:
                    vuln_id = vuln.get('id', '')
                    aliases = vuln.get('aliases', [])
                    # Normalize all aliases (upper, strip)
                    all_ids = {vuln_id.upper().strip()} | {a.upper().strip() for a in aliases}
                    # Prepare description-based deduplication key
                    desc = (vuln.get('summary', '') or vuln.get('details', '') or '').strip().lower()
                    affected_versions = str(self._extract_osv_affected_versions(vuln)).strip().lower()
                    desc_ver_key = (desc, affected_versions)
                    # Check if any alias has been seen
                    if any(a in seen_aliases for a in all_ids):
                        print(f"   ‚è≠Ô∏è Skipping duplicate vulnerability: {vuln_id} (alias already processed)")
                        continue
                    # Check if description+affected_versions has been seen
                    if desc and desc_ver_key in seen_desc_versions:
                        print(f"   ‚è≠Ô∏è Skipping duplicate vulnerability: {vuln_id} (description+affected_versions match)")
                        continue
                    is_current, is_future = self._is_osv_vulnerability_relevant(vuln, package_name, version)
                    if is_current:
                        vuln_obj = self._parse_osv_vulnerability(vuln, package_name)
                        if vuln_obj:
                            vulnerabilities.append(vuln_obj)
                            for a in all_ids:
                                alias_to_canonical[a] = len(vulnerabilities) - 1
                                seen_aliases.add(a)
                            if desc:
                                seen_desc_versions.add(desc_ver_key)
                            print(f"   ‚úÖ Found vulnerability: {vuln_obj.cve_id}")
                    elif is_future:
                        vuln_obj = self._parse_osv_vulnerability(vuln, package_name)
                        if vuln_obj:
                            vuln_obj.future_vuln = True
                            vulnerabilities.append(vuln_obj)
                            for a in all_ids:
                                alias_to_canonical[a] = len(vulnerabilities) - 1
                                seen_aliases.add(a)
                            if desc:
                                seen_desc_versions.add(desc_ver_key)
                            print(f"   ‚ö†Ô∏è Found future vulnerability: {vuln_obj.cve_id}")
            elif response.status_code == 429:
                print(f"   ‚ö†Ô∏è Rate limit exceeded for {package_name}, waiting 5 seconds...")
                time.sleep(5)
            else:
                print(f"   ‚ö†Ô∏è OSV API returned status {response.status_code} for {package_name}")
            print(f"   üìã Total vulnerabilities found: {len(vulnerabilities)}")
        except requests.exceptions.Timeout:
            print(f"   ‚ùå Timeout searching vulnerabilities for {package_name}")
        except requests.exceptions.RequestException as e:
            print(f"   ‚ùå Network error searching vulnerabilities for {package_name}: {e}")
        except Exception as e:
            print(f"   ‚ùå Error searching vulnerabilities for {package_name}: {e}")
        has_data_available = True
        if len(vulnerabilities) == 0:
            has_data_available = True
            print(f"   ‚ö†Ô∏è {package_name} has no vulnerability data available")
        return vulnerabilities, has_data_available

    def _is_osv_vulnerability_relevant(self, vuln: Dict, package_name: str, version: str) -> tuple:
        """Check if OSV vulnerability affects the current package version (robust interval logic)."""
        try:
            from packaging import version as pkg_version
            current = pkg_version.parse(version)
            affected = vuln.get('affected', [])
            intervals = []
            for affected_pkg in affected:
                pkg = affected_pkg.get('package', {})
                if pkg.get('name') == package_name and pkg.get('ecosystem') == 'PyPI':
                    ranges = affected_pkg.get('ranges', [])
                    if not ranges:
                        # No ranges: affects all versions
                        return (True, False)
                    for range_info in ranges:
                        events = range_info.get('events', [])
                        intro = None
                        fixed = None
                        for event in events:
                            if 'introduced' in event:
                                intro = event['introduced']
                            if 'fixed' in event:
                                fixed = event['fixed']
                            if 'last_affected' in event:
                                fixed = event['last_affected']
                        if intro:
                            intervals.append((intro, fixed))
            if not intervals:
                # No intervals found, treat as affecting all versions
                return (True, False)
            # Check if current version is in any interval
            for intro, fixed in intervals:
                intro_v = pkg_version.parse(intro)
                if fixed:
                    fixed_v = pkg_version.parse(fixed)
                    if intro_v <= current < fixed_v:
                        return (True, False)
                else:
                    if current >= intro_v:
                        return (True, False)
            # If not in any interval, check if it's a future vuln
            min_intro = min(pkg_version.parse(i[0]) for i in intervals if i[0])
            if current < min_intro:
                return (False, True)
            return (False, False)
        except Exception as e:
            print(f"      ‚ùå Error checking OSV vulnerability relevance: {e}")
            return (False, False)

    def _parse_cvss_vector_to_severity(self, cvss_vector: str) -> Severity:
        """Parse CVSS vector string to extract severity level using proper CVSS v3.1 algorithm."""
        try:
            # Extract the vector part after "CVSS:3.1/" or "CVSS:4.0/"
            if "CVSS:" in cvss_vector:
                vector_part = cvss_vector.split("CVSS:")[1].split("/", 1)[1]
                
                # Parse CVSS v3.1 vector components
                components = {}
                for part in vector_part.split('/'):
                    if ':' in part:
                        key, value = part.split(':', 1)
                        components[key] = value
                
                # Calculate Base Score using CVSS v3.1 algorithm
                base_score = self._calculate_cvss_v3_base_score(components)
                severity = self._cvss_score_to_severity(base_score)
                
                print(f"[DEBUG] Parsed CVSS vector '{cvss_vector}' to score: {base_score}, severity: {severity}")
                return severity
                        
        except Exception as e:
            print(f"[DEBUG] Error parsing CVSS vector '{cvss_vector}': {e}")
        
        return Severity.NONE

    def _calculate_cvss_v3_base_score(self, components: dict) -> float:
        """Calculate CVSS v3.1 Base Score using the official algorithm."""
        
        # Impact Subscore calculation
        impact_subscore = 0.0
        
        # Confidentiality Impact
        if components.get('C') == 'H':
            impact_subscore += 0.56
        elif components.get('C') == 'L':
            impact_subscore += 0.22
        elif components.get('C') == 'N':
            impact_subscore += 0.0
            
        # Integrity Impact
        if components.get('I') == 'H':
            impact_subscore += 0.56
        elif components.get('I') == 'L':
            impact_subscore += 0.22
        elif components.get('I') == 'N':
            impact_subscore += 0.0
            
        # Availability Impact
        if components.get('A') == 'H':
            impact_subscore += 0.56
        elif components.get('A') == 'L':
            impact_subscore += 0.22
        elif components.get('A') == 'N':
            impact_subscore += 0.0
        
        # If Impact Subscore is 0, return 0
        if impact_subscore == 0:
            return 0.0
        
        # Exploitability Subscore calculation
        exploitability_subscore = 8.22
        
        # Attack Vector
        if components.get('AV') == 'N':
            exploitability_subscore *= 0.85
        elif components.get('AV') == 'A':
            exploitability_subscore *= 0.62
        elif components.get('AV') == 'L':
            exploitability_subscore *= 0.55
        elif components.get('AV') == 'P':
            exploitability_subscore *= 0.2
            
        # Attack Complexity
        if components.get('AC') == 'L':
            exploitability_subscore *= 0.77
        elif components.get('AC') == 'H':
            exploitability_subscore *= 0.44
            
        # Privileges Required
        if components.get('PR') == 'N':
            exploitability_subscore *= 0.85
        elif components.get('PR') == 'L':
            exploitability_subscore *= 0.62
        elif components.get('PR') == 'H':
            exploitability_subscore *= 0.27
            
        # User Interaction
        if components.get('UI') == 'N':
            exploitability_subscore *= 0.85
        elif components.get('UI') == 'R':
            exploitability_subscore *= 0.62
        
        # Scope
        scope_changed = components.get('S') == 'C'
        
        # Calculate Base Score
        if impact_subscore <= 0:
            base_score = 0.0
        elif scope_changed:
            base_score = min(10.0, 1.08 * (impact_subscore + exploitability_subscore))
        else:
            base_score = min(10.0, impact_subscore + exploitability_subscore)
        
        # Round to 1 decimal place
        return round(base_score, 1)

    def _parse_osv_vulnerability(self, vuln: Dict, package_name: str) -> Optional[Vulnerability]:
        """Parse OSV vulnerability data into Vulnerability object (severity-focused approach)."""
        try:
            vuln_id = vuln.get('id', '')
            summary = vuln.get('summary', '')
            details = vuln.get('details', '')
            description = summary if summary else details

            print(f"[DEBUG] Parsing {vuln_id} for {package_name}")
            print(f"[DEBUG] Severity array: {vuln.get('severity', [])}")
            print(f"[DEBUG] Database specific: {vuln.get('database_specific', {})}")

            # Priority 1: Check database_specific.severity (most reliable)
            severity = Severity.NONE
            cvss_score = None
            if 'database_specific' in vuln and 'severity' in vuln['database_specific']:
                severity_str = vuln['database_specific']['severity'].lower()
                severity = self._parse_severity(severity_str)
                if severity != Severity.NONE:
                    cvss_score = self._severity_to_cvss_estimate(severity)
                    print(f"[DEBUG] Using database_specific severity: {severity_str} -> {severity} (CVSS: {cvss_score})")
                    # Return early if we have a valid severity
                    affected_versions = self._extract_osv_affected_versions(vuln)
                    references = [ref["url"] for ref in vuln.get("references", []) if ref.get("url")]
                    if vuln_id:
                        references.append(f'https://osv.dev/vulnerability/{vuln_id}')
                    if not references:
                        if vuln_id.startswith('CVE-'):
                            references.append(f'https://cve.mitre.org/cgi-bin/cvename.cgi?name={vuln_id}')
                        elif vuln_id.startswith('GHSA-'):
                            references.append(f'https://github.com/advisories/{vuln_id}')
                    references = list(dict.fromkeys(references))
                    recommendation = self._generate_vulnerability_recommendation(severity, package_name)
                    return Vulnerability(
                        id=vuln_id,
                        title=vuln_id,
                        description=description,
                        severity=severity,
                        cve_id=vuln_id,
                        cvss_score=cvss_score,
                        affected_versions=affected_versions,
                        references=references,
                        recommendation=recommendation
                    )
            # Priority 2: Try to extract from severity array (CVSS_V3 only)
            if severity == Severity.NONE:
                severity_array = vuln.get("severity", [])
                for severity_item in severity_array:
                    if severity_item.get("type") == "CVSS_V3":
                        score_value = severity_item.get("score", "")
                        if score_value.startswith("CVSS:"):
                            # Parse CVSS vector to get severity level, not exact score
                            estimated_severity = self._parse_cvss_vector_to_severity(score_value)
                            if estimated_severity != Severity.NONE:
                                severity = estimated_severity
                                cvss_score = self._severity_to_cvss_estimate(severity)
                                print(f"[DEBUG] Parsed CVSS vector to severity: {severity} (CVSS: {cvss_score})")
                        else:
                            # Try to parse as numeric score
                            try:
                                cvss_score = float(score_value)
                                severity = self._cvss_score_to_severity(cvss_score)
                                print(f"[DEBUG] Parsed numeric CVSS: {cvss_score} -> {severity}")
                            except (ValueError, TypeError):
                                pass

            # Priority 3: Try database_specific.cvss.score if available
            if severity == Severity.NONE and 'database_specific' in vuln:
                db_specific = vuln['database_specific']
                if 'cvss' in db_specific and 'score' in db_specific['cvss']:
                    try:
                        cvss_score = float(db_specific['cvss']['score'])
                        severity = self._cvss_score_to_severity(cvss_score)
                        print(f"[DEBUG] Found CVSS in database_specific: {cvss_score} -> {severity}")
                    except (ValueError, TypeError):
                        pass

            # Priority 4: Final fallback - estimate from description
            if severity == Severity.NONE and description:
                severity = self._estimate_severity_from_description(description)
                if severity != Severity.NONE:
                    cvss_score = self._severity_to_cvss_estimate(severity)
                    print(f"[DEBUG] Estimated severity from description: {severity} (CVSS: {cvss_score})")

            # Set defaults if still missing
            if cvss_score is None:
                cvss_score = 0.0
            
            print(f"[DEBUG] Final severity: {severity}, CVSS score: {cvss_score}")

            # Get affected versions
            affected_versions = self._extract_osv_affected_versions(vuln)

            # Extract references directly from references array
            references = [ref["url"] for ref in vuln.get("references", []) if ref.get("url")]
            
            # Always add the OSV advisory link
            if vuln_id:
                references.append(f'https://osv.dev/vulnerability/{vuln_id}')
            
            # Fallback references if none found
            if not references:
                if vuln_id.startswith('CVE-'):
                    references.append(f'https://cve.mitre.org/cgi-bin/cvename.cgi?name={vuln_id}')
                elif vuln_id.startswith('GHSA-'):
                    references.append(f'https://github.com/advisories/{vuln_id}')

            # Remove duplicate references
            references = list(dict.fromkeys(references))
            
            # Generate recommendation
            recommendation = self._generate_vulnerability_recommendation(severity, package_name)
            
            return Vulnerability(
                id=vuln_id,
                title=vuln_id,
                description=description,
                severity=severity,
                cve_id=vuln_id,
                cvss_score=cvss_score,
                affected_versions=affected_versions,
                references=references,
                recommendation=recommendation
            )
        except Exception as e:
            print(f"Error parsing OSV vulnerability: {e}\nFull vuln dict: {vuln}")
            # Return a minimal Vulnerability object with as much info as possible
            try:
                return Vulnerability(
                    id=vuln.get('id', 'unknown'),
                    title=vuln.get('id', 'unknown'),
                    description=vuln.get('summary', '') or vuln.get('details', '') or 'No description',
                    severity=Severity.NONE,
                    cve_id=vuln.get('id', 'unknown'),
                    cvss_score=0.0,
                    affected_versions=None,
                    references=[],
                    recommendation=f"Review {package_name} for potential security updates. (Parse error)"
                )
            except Exception as e2:
                print(f"Error creating fallback Vulnerability object: {e2}\nVuln dict: {vuln}")
                return None

    def _extract_osv_affected_versions(self, vuln: Dict) -> Optional[str]:
        """Extract affected version information from OSV vulnerability."""
        try:
            affected = vuln.get('affected', [])
            version_ranges = []
            
            for affected_pkg in affected:
                ranges = affected_pkg.get('ranges', [])
                for range_info in ranges:
                    events = range_info.get('events', [])
                    for event in events:
                        if 'introduced' in event and 'fixed' in event:
                            version_ranges.append(f"{event['introduced']} to {event['fixed']}")
                        elif 'introduced' in event:
                            version_ranges.append(f"{event['introduced']} and later")
                        elif 'fixed' in event:
                            version_ranges.append(f"before {event['fixed']}")
                        elif 'last_affected' in event:
                            version_ranges.append(f"up to {event['last_affected']}")
            
            if version_ranges:
                return "; ".join(version_ranges)
            else:
                return "Version information not available"
            
        except Exception as e:
            print(f"Error extracting OSV affected versions: {e}")
            return "Version information not available"

    def _cvss_score_to_severity(self, cvss_score: float) -> Severity:
        """Convert CVSS score to severity level."""
        if cvss_score >= 9.0:
            return Severity.CRITICAL
        elif cvss_score >= 7.0:
            return Severity.HIGH
        elif cvss_score >= 4.0:
            return Severity.MEDIUM
        elif cvss_score >= 0.1:
            return Severity.LOW
        else:
            return Severity.NONE

    def _severity_to_cvss_estimate(self, severity: Severity) -> float:
        """Estimate CVSS score based on severity level."""
        severity_estimates = {
            Severity.CRITICAL: 9.5,
            Severity.HIGH: 8.0,
            Severity.MEDIUM: 5.5,
            Severity.LOW: 3.0,
            Severity.NONE: 0.0
        }
        return severity_estimates.get(severity, 0.0)

    def _estimate_severity_from_description(self, description: str) -> Severity:
        """Estimate severity from vulnerability description keywords."""
        desc_lower = description.lower()
        
        # Critical indicators
        critical_keywords = ['remote code execution', 'rce', 'arbitrary code execution', 'critical', 'severe']
        if any(keyword in desc_lower for keyword in critical_keywords):
            return Severity.CRITICAL
        
        # High indicators
        high_keywords = ['high', 'privilege escalation', 'authentication bypass', 'sql injection', 'xss', 'cross-site scripting']
        if any(keyword in desc_lower for keyword in high_keywords):
            return Severity.HIGH
        
        # Medium indicators
        medium_keywords = ['medium', 'information disclosure', 'denial of service', 'dos', 'ddos']
        if any(keyword in desc_lower for keyword in medium_keywords):
            return Severity.MEDIUM
        
        # Low indicators
        low_keywords = ['low', 'minor', 'cosmetic']
        if any(keyword in desc_lower for keyword in low_keywords):
            return Severity.LOW
        
        # Default to medium if no clear indicators
        return Severity.MEDIUM



    def _parse_severity(self, severity_str: str) -> Severity:
        """Parse severity string to Severity enum (handles OSV's severity values)."""
        if not severity_str:
            return Severity.NONE
        
        severity_lower = severity_str.lower().strip()
        
        # Map OSV severity values to our enum
        if severity_lower in ['critical', 'crit']:
            return Severity.CRITICAL
        elif severity_lower in ['high', 'severe']:
            return Severity.HIGH
        elif severity_lower in ['moderate', 'medium', 'mod']:
            return Severity.MEDIUM
        elif severity_lower in ['low', 'minor']:
            return Severity.LOW
        else:
            print(f"[DEBUG] Unknown severity value: '{severity_str}', defaulting to NONE")
            return Severity.NONE

    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate risk score based on vulnerabilities using OSV data."""
        if not vulnerabilities:
            return 0.0
        
        total_score = 0.0
        vuln_count = len(vulnerabilities)
        
        # Count vulnerabilities by severity - include NONE
        severity_counts = {
            Severity.CRITICAL: 0,
            Severity.HIGH: 0,
            Severity.MEDIUM: 0,
            Severity.LOW: 0,
            Severity.NONE: 0
        }
        
        # Calculate base scores for non-NONE vulnerabilities
        for vuln in vulnerabilities:
            # Safely increment severity count
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
            
            # Skip NONE severity vulnerabilities in score calculation
            if vuln.severity == Severity.NONE:
                continue
                
            # Base score from CVSS (0-10 scale)
            cvss_score = vuln.cvss_score or 0.0
            
            # Severity multiplier based on OSV severity classification
            severity_multiplier = self.severity_weights.get(vuln.severity, 1.0)
            
            # Calculate individual vulnerability score
            vuln_score = cvss_score * severity_multiplier
            
            # Additional factors for OSV data
            if vuln.future_vuln:
                # Future vulnerabilities get reduced weight (less urgent)
                vuln_score *= 0.7
            
            # Check if vulnerability has detailed version information
            if vuln.affected_versions and vuln.affected_versions != "Version information not available":
                # More precise version info increases confidence
                vuln_score *= 1.1
            
            # Check if vulnerability has references (indicates well-documented)
            if vuln.references and len(vuln.references) > 0:
                vuln_score *= 1.05
            
            total_score += vuln_score
        
        # Count non-NONE vulnerabilities for multiplier calculations
        non_none_count = vuln_count - severity_counts[Severity.NONE]
        
        # Special handling for different vulnerability combinations
        if severity_counts[Severity.CRITICAL] > 0:
            # Critical vulnerabilities dominate the score
            if severity_counts[Severity.CRITICAL] >= 2:
                total_score = min(total_score, 95.0)  # Cap at very high but not max
            else:
                total_score = min(total_score, 90.0)  # Single critical vulnerability
        elif severity_counts[Severity.HIGH] > 0:
            # High vulnerabilities are significant
            if severity_counts[Severity.HIGH] >= 3:
                total_score = min(total_score, 85.0)  # Multiple high vulnerabilities
            elif severity_counts[Severity.HIGH] >= 2:
                total_score = min(total_score, 75.0)  # Two high vulnerabilities
            else:
                total_score = min(total_score, 70.0)  # Single high vulnerability
        elif severity_counts[Severity.MEDIUM] > 0:
            # Medium vulnerabilities are moderate risk
            if severity_counts[Severity.MEDIUM] >= 5:
                total_score = min(total_score, 65.0)  # Many medium vulnerabilities
            elif severity_counts[Severity.MEDIUM] >= 3:
                total_score = min(total_score, 55.0)  # Several medium vulnerabilities
            else:
                total_score = min(total_score, 50.0)  # Few medium vulnerabilities
        
        # Apply vulnerability count multiplier (more vulns = higher risk)
        # Only count non-NONE vulnerabilities for multiplier
        if non_none_count > 1:
            # Reduced multiplier effect - 2% increase per additional vuln instead of 3%
            count_multiplier = 1.0 + (non_none_count - 1) * 0.02
            total_score *= count_multiplier
        
        # Normalize to 0-100 scale
        normalized_score = min(total_score, 100.0)
        
        return round(normalized_score, 1)

    def _determine_risk_level(self, risk_score: float, vulnerability_count: int = 0) -> str:
        """Determine risk level based on score and vulnerability count."""
        # If no vulnerabilities found, always return safe
        if vulnerability_count == 0:
            return "safe"
        
        # Special handling for known critical packages
        # Note: This should be coordinated with the health checker
        # For now, we'll handle pycrypto specifically here
        
        # If any vulnerabilities found, minimum risk level is "low"
        # Determine based on risk score, but never go below "low" if vulnerabilities exist
        if risk_score >= self.risk_thresholds["critical"]:
            return "critical"
        elif risk_score >= self.risk_thresholds["high"]:
            return "high"
        elif risk_score >= self.risk_thresholds["medium"]:
            return "medium"
        elif risk_score >= self.risk_thresholds["low"]:
            return "low"
        else:
            # If vulnerabilities exist but score is below low threshold, still return "low"
            return "low"

    def _generate_recommendation(self, vulnerabilities: List[Vulnerability], risk_level: str) -> str:
        """Generate overall recommendation for the package."""
        if not vulnerabilities:
            return "This package appears to be secure with no known vulnerabilities."
        
        if risk_level == "critical":
            return "CRITICAL: This package has severe vulnerabilities. Consider replacing it with a secure alternative or updating to a patched version immediately."
        elif risk_level == "high":
            return "HIGH RISK: This package has high-severity vulnerabilities. Update to the latest secure version as soon as possible."
        elif risk_level == "medium":
            return "MEDIUM RISK: This package has moderate vulnerabilities. Consider updating to a newer version when possible."
        elif risk_level == "low":
            return "LOW RISK: This package has minor vulnerabilities. Monitor for updates and apply them when available."
        else:
            return "This package has minimal security concerns."

    def _generate_vulnerability_recommendation(self, severity: Severity, package_name: str) -> str:
        """Generate specific recommendation for a vulnerability."""
        base_recommendations = {
            Severity.CRITICAL: f"Immediately update {package_name} to the latest secure version or consider alternative packages.",
            Severity.HIGH: f"Update {package_name} to a patched version as soon as possible.",
            Severity.MEDIUM: f"Consider updating {package_name} to a newer version when convenient.",
            Severity.LOW: f"Monitor {package_name} for security updates and apply them when available.",
            Severity.NONE: f"No specific action required for {package_name}."
        }
        return base_recommendations.get(severity, f"Review {package_name} for potential security updates.")

    def _create_safe_package_risk(self, package_name: str, version: str) -> PackageRisk:
        """Create a safe package risk object when scanning fails."""
        return PackageRisk(
            package_name=package_name,
            version=version,
            risk_score=0.0,
            risk_level="safe",
            vulnerability_count=0,
            vulnerabilities=[],
            recommendation="No vulnerabilities found for this package."
        )

    def _create_na_package_risk(self, package_name: str, version: str) -> PackageRisk:
        """Create an N/A package risk object when vulnerability data is not available."""
        return PackageRisk(
            package_name=package_name,
            version=version,
            risk_score=0.0,
            risk_level="na",
            vulnerability_count=0,
            vulnerabilities=[],
            recommendation="Cannot scan vulnerabilities - no vulnerability data available for this package."
        )



    def scan_dependencies(self, dependencies: List[Dict]) -> Dict[str, PackageRisk]:
        """Scan a list of dependencies for vulnerabilities using parallel processing."""
        results = {}
        
        # Filter out dependencies without name or version
        valid_deps = [dep for dep in dependencies if dep.get('name') and dep.get('version')]
        
        if not valid_deps:
            return results
        
        print(f"üîç Will scan {len(valid_deps)} packages with known versions")
        
        # Use ThreadPoolExecutor for parallel processing
        # Limit to 5 concurrent threads to avoid overwhelming the OSV API
        max_workers = min(5, len(valid_deps))
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Submit all scan tasks
            future_to_dep = {
                executor.submit(self.scan_package, dep['name'], dep['version']): dep['name']
                for dep in valid_deps
            }
            
            # Collect results as they complete
            for future in as_completed(future_to_dep):
                dep_name = future_to_dep[future]
                try:
                    risk = future.result()
                    results[dep_name] = risk
                except Exception as e:
                    print(f"‚ùå Error scanning {dep_name}: {e}")
                    # Create a safe fallback result
                    results[dep_name] = self._create_safe_package_risk(dep_name, "unknown")
        
        return results

def test_tensorflow_vulnerability_count():
    """Standalone test to fetch and print the number of unique vulnerabilities for TensorFlow 1.15.0."""
    scanner = VulnerabilityScanner()
    package_name = "tensorflow"
    version = "1.15.0"
    print(f"\n=== TEST: Fetching vulnerabilities for {package_name} {version} ===")
    package_risk = scanner.scan_package(package_name, version)
    print(f"Package: {package_risk.package_name} {package_risk.version}")
    print(f"Vulnerability count: {package_risk.vulnerability_count}")
    print("Vulnerability IDs:")
    for vuln in package_risk.vulnerabilities:
        print(f"- {vuln.cve_id or vuln.id}")
    print("=== END TEST ===\n")

def fetch_osv_raw_vulnerability_count():
    """Directly fetch and print the number of vulnerabilities for tensorflow 1.15.0 from OSV API (raw, no deduplication)."""
    import requests
    import json
    osv_api_url = "https://api.osv.dev/v1/query"
    query = {
        "package": {
            "name": "tensorflow",
            "ecosystem": "PyPI"
        },
        "version": "1.15.0"
    }
    print("\n=== OSV RAW FETCH TEST ===")
    response = requests.post(osv_api_url, json=query, timeout=15)
    if response.status_code == 200:
        data = response.json()
        vulns = data.get('vulns', [])
        print(f"Raw OSV API returned {len(vulns)} vulnerabilities for tensorflow 1.15.0.")
        print("First 5 vulnerability IDs:")
        for v in vulns[:5]:
            print(f"- {v.get('id')}")
        print("=== END OSV RAW FETCH TEST ===\n")
    else:
        print(f"OSV API request failed with status {response.status_code}")

def test_package_vulnerability_counts():
    """Test function to check actual vulnerability counts for specific packages."""
    scanner = VulnerabilityScanner()
    test_packages = [
        ("black", "23.0.0"),
        ("django-rest-framework", "0.1.0"),
        ("requests", "2.31.0"),
        ("pycrypto", "2.6.1"),
        ("fastapi", "0.111.0"),
        ("flask", "3.0.0"),
        ("numpy", "1.26.0"),
        ("pandas", "2.2.0")
    ]
    
    print("\n=== TESTING PACKAGE VULNERABILITY COUNTS ===")
    for package_name, version in test_packages:
        print(f"\n--- Testing {package_name} {version} ---")
        try:
            package_risk = scanner.scan_package(package_name, version)
            print(f"Risk Level: {package_risk.risk_level}")
            print(f"Vulnerability Count: {package_risk.vulnerability_count}")
            print(f"Risk Score: {package_risk.risk_score}")
            if package_risk.vulnerabilities:
                print("Vulnerabilities:")
                for i, vuln in enumerate(package_risk.vulnerabilities[:3]):  # Show first 3
                    print(f"  {i+1}. {vuln.cve_id or vuln.id} - {vuln.severity.value}")
                if len(package_risk.vulnerabilities) > 3:
                    print(f"  ... and {len(package_risk.vulnerabilities) - 3} more")
            else:
                print("No vulnerabilities found")
        except Exception as e:
            print(f"Error testing {package_name}: {e}")
    
    print("\n=== END TESTING ===")

if __name__ == "__main__":
    test_tensorflow_vulnerability_count()
    fetch_osv_raw_vulnerability_count()
    test_package_vulnerability_counts()